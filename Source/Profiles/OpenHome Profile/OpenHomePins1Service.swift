//
//  Copyright (c) 2023 Katoemba Software, (https://rigelian.net/)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//
//  Generated by SwiftUPnP/UPnPCodeGenerator
//

import Foundation
import Combine
import XMLCoder
import os.log

public class OpenHomePins1Service: UPnPService, @unchecked Sendable {
	struct Envelope<T: Codable>: Codable {
		enum CodingKeys: String, CodingKey {
			case body = "s:Body"
		}

		var body: T
	}

	public struct GetDeviceMaxResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case deviceMax = "DeviceMax"
		}

		public var deviceMax: UInt32

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))GetDeviceMaxResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))deviceMax: \(deviceMax)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func getDeviceMax(log: UPnPService.MessageLog = .none) async throws -> GetDeviceMaxResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:GetDeviceMax"
				case response = "u:GetDeviceMaxResponse"
			}

			var action: SoapAction?
			var response: GetDeviceMaxResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "GetDeviceMax", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct GetAccountMaxResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case accountMax = "AccountMax"
		}

		public var accountMax: UInt32

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))GetAccountMaxResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))accountMax: \(accountMax)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func getAccountMax(log: UPnPService.MessageLog = .none) async throws -> GetAccountMaxResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:GetAccountMax"
				case response = "u:GetAccountMaxResponse"
			}

			var action: SoapAction?
			var response: GetAccountMaxResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "GetAccountMax", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct GetModesResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case modes = "Modes"
		}

		public var modes: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))GetModesResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))modes: '\(modes)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func getModes(log: UPnPService.MessageLog = .none) async throws -> GetModesResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:GetModes"
				case response = "u:GetModesResponse"
			}

			var action: SoapAction?
			var response: GetModesResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "GetModes", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct GetIdArrayResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case idArray = "IdArray"
		}

		public var idArray: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))GetIdArrayResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))idArray: '\(idArray)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func getIdArray(log: UPnPService.MessageLog = .none) async throws -> GetIdArrayResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:GetIdArray"
				case response = "u:GetIdArrayResponse"
			}

			var action: SoapAction?
			var response: GetIdArrayResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "GetIdArray", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct GetCloudConnectedResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case cloudConnected = "CloudConnected"
		}

		public var cloudConnected: Bool

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))GetCloudConnectedResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))cloudConnected: \(cloudConnected == true ? "true" : "false")")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func getCloudConnected(log: UPnPService.MessageLog = .none) async throws -> GetCloudConnectedResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:GetCloudConnected"
				case response = "u:GetCloudConnectedResponse"
			}

			var action: SoapAction?
			var response: GetCloudConnectedResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "GetCloudConnected", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct ReadListResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case list = "List"
		}

		public var list: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))ReadListResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))list: '\(list)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func readList(ids: String, log: UPnPService.MessageLog = .none) async throws -> ReadListResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case ids = "Ids"
			}

			@Attribute var urn: String
			public var ids: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:ReadList"
				case response = "u:ReadListResponse"
			}

			var action: SoapAction?
			var response: ReadListResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "ReadList", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), ids: ids))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public func invokeId(id: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
			}

			@Attribute var urn: String
			public var id: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:InvokeId"
			}

			var action: SoapAction
		}
		try await post(action: "InvokeId", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id))), log: log)
	}

	public func invokeIndex(index: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case index = "Index"
			}

			@Attribute var urn: String
			public var index: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:InvokeIndex"
			}

			var action: SoapAction
		}
		try await post(action: "InvokeIndex", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), index: index))), log: log)
	}

	public func invokeUri(mode: String, type: String, uri: String, shuffle: Bool, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case mode = "Mode"
				case type = "Type"
				case uri = "Uri"
				case shuffle = "Shuffle"
			}

			@Attribute var urn: String
			public var mode: String
			public var type: String
			public var uri: String
			public var shuffle: Bool
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:InvokeUri"
			}

			var action: SoapAction
		}
		try await post(action: "InvokeUri", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), mode: mode, type: type, uri: uri, shuffle: shuffle))), log: log)
	}

	public func setDevice(index: UInt32, mode: String, type: String, uri: String, title: String, description: String, artworkUri: String, shuffle: Bool, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case index = "Index"
				case mode = "Mode"
				case type = "Type"
				case uri = "Uri"
				case title = "Title"
				case description = "Description"
				case artworkUri = "ArtworkUri"
				case shuffle = "Shuffle"
			}

			@Attribute var urn: String
			public var index: UInt32
			public var mode: String
			public var type: String
			public var uri: String
			public var title: String
			public var description: String
			public var artworkUri: String
			public var shuffle: Bool
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:SetDevice"
			}

			var action: SoapAction
		}
		try await post(action: "SetDevice", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), index: index, mode: mode, type: type, uri: uri, title: title, description: description, artworkUri: artworkUri, shuffle: shuffle))), log: log)
	}

	public func setAccount(index: UInt32, mode: String, type: String, uri: String, title: String, description: String, artworkUri: String, shuffle: Bool, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case index = "Index"
				case mode = "Mode"
				case type = "Type"
				case uri = "Uri"
				case title = "Title"
				case description = "Description"
				case artworkUri = "ArtworkUri"
				case shuffle = "Shuffle"
			}

			@Attribute var urn: String
			public var index: UInt32
			public var mode: String
			public var type: String
			public var uri: String
			public var title: String
			public var description: String
			public var artworkUri: String
			public var shuffle: Bool
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:SetAccount"
			}

			var action: SoapAction
		}
		try await post(action: "SetAccount", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), index: index, mode: mode, type: type, uri: uri, title: title, description: description, artworkUri: artworkUri, shuffle: shuffle))), log: log)
	}

	public func clear(id: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
			}

			@Attribute var urn: String
			public var id: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:Clear"
			}

			var action: SoapAction
		}
		try await post(action: "Clear", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id))), log: log)
	}

	public func swap(index1: UInt32, index2: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case index1 = "Index1"
				case index2 = "Index2"
			}

			@Attribute var urn: String
			public var index1: UInt32
			public var index2: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:Swap"
			}

			var action: SoapAction
		}
		try await post(action: "Swap", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), index1: index1, index2: index2))), log: log)
	}

}

// Event parser
extension OpenHomePins1Service {
	public struct State: Codable {
		enum CodingKeys: String, CodingKey {
			case deviceMax = "DeviceMax"
			case accountMax = "AccountMax"
			case modes = "Modes"
			case idArray = "IdArray"
			case cloudConnected = "CloudConnected"
		}

		public var deviceMax: UInt32?
		public var accountMax: UInt32?
		public var modes: String?
		public var idArray: String?
		public var cloudConnected: Bool?

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))OpenHomePins1ServiceState {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))deviceMax: \(deviceMax ?? 0)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))accountMax: \(accountMax ?? 0)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))modes: '\(modes ?? "nil")'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))idArray: '\(idArray ?? "nil")'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))cloudConnected: \((cloudConnected == nil) ? "nil" : (cloudConnected! == true ? "true" : "false"))")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}

	public func state(xml: Data) throws -> State {
		struct PropertySet: Codable {
			var property: [State]
		}

		let decoder = XMLDecoder()
		decoder.shouldProcessNamespaces = true
		let propertySet = try decoder.decode(PropertySet.self, from: xml)

		return propertySet.property.reduce(State()) { partialResult, property in
			var result = partialResult
			if let deviceMax = property.deviceMax {
				result.deviceMax = deviceMax
			}
			if let accountMax = property.accountMax {
				result.accountMax = accountMax
			}
			if let modes = property.modes {
				result.modes = modes
			}
			if let idArray = property.idArray {
				result.idArray = idArray
			}
			if let cloudConnected = property.cloudConnected {
				result.cloudConnected = cloudConnected
			}
			return result
		}
	}

	public var stateSubject: AnyPublisher<State, Never> {
		subscribedEventPublisher
			.compactMap { [weak self] in
				guard let self else { return nil }

				return try? self.state(xml: $0)
			}
			.eraseToAnyPublisher()
	}

	public var stateChangeStream: AsyncStream<State> {
		stateSubject.stream
	}
}
