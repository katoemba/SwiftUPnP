//
//  Copyright (c) 2023 Katoemba Software, (https://rigelian.net/)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//
//  Generated by SwiftUPnP/UPnPCodeGenerator
//

import Foundation
import Combine
import XMLCoder
import os.log

public class OpenHomePlaylistManager1Service: UPnPService {
	struct Envelope<T: Codable>: Codable {
		enum CodingKeys: String, CodingKey {
			case body = "s:Body"
		}

		var body: T
	}

	public struct MetadataResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case metadata = "Metadata"
		}

		public var metadata: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))MetadataResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))metadata: '\(metadata)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func metadata(log: UPnPService.MessageLog = .none) async throws -> MetadataResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:Metadata"
				case response = "u:MetadataResponse"
			}

			var action: SoapAction?
			var response: MetadataResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "Metadata", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct ImagesXmlResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case imagesXml = "ImagesXml"
		}

		public var imagesXml: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))ImagesXmlResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))imagesXml: '\(imagesXml)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func imagesXml(log: UPnPService.MessageLog = .none) async throws -> ImagesXmlResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:ImagesXml"
				case response = "u:ImagesXmlResponse"
			}

			var action: SoapAction?
			var response: ImagesXmlResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "ImagesXml", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct PlaylistReadArrayResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case arrayData = "Array"
		}

		public var arrayData: Data?
		public var array: [UInt32]? {
			arrayData?.toArray(type: UInt32.self).map { $0.bigEndian }
		}

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))PlaylistReadArrayResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func playlistReadArray(id: UInt32, log: UPnPService.MessageLog = .none) async throws -> PlaylistReadArrayResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
			}

			@Attribute var urn: String
			public var id: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistReadArray"
				case response = "u:PlaylistReadArrayResponse"
			}

			var action: SoapAction?
			var response: PlaylistReadArrayResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "PlaylistReadArray", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct PlaylistReadListResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case playlistList = "PlaylistList"
		}

		public var playlistList: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))PlaylistReadListResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))playlistList: '\(playlistList)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func playlistReadList(idList: String, log: UPnPService.MessageLog = .none) async throws -> PlaylistReadListResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case idList = "IdList"
			}

			@Attribute var urn: String
			public var idList: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistReadList"
				case response = "u:PlaylistReadListResponse"
			}

			var action: SoapAction?
			var response: PlaylistReadListResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "PlaylistReadList", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), idList: idList))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct PlaylistReadResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case name = "Name"
			case description = "Description"
			case imageId = "ImageId"
		}

		public var name: String
		public var description: String
		public var imageId: UInt32

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))PlaylistReadResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))name: '\(name)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))description: '\(description)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))imageId: \(imageId)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func playlistRead(id: UInt32, log: UPnPService.MessageLog = .none) async throws -> PlaylistReadResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
			}

			@Attribute var urn: String
			public var id: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistRead"
				case response = "u:PlaylistReadResponse"
			}

			var action: SoapAction?
			var response: PlaylistReadResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "PlaylistRead", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public func playlistSetName(id: UInt32, name: String, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
				case name = "Name"
			}

			@Attribute var urn: String
			public var id: UInt32
			public var name: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistSetName"
			}

			var action: SoapAction
		}
		try await post(action: "PlaylistSetName", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id, name: name))), log: log)
	}

	public func playlistSetDescription(id: UInt32, description: String, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
				case description = "Description"
			}

			@Attribute var urn: String
			public var id: UInt32
			public var description: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistSetDescription"
			}

			var action: SoapAction
		}
		try await post(action: "PlaylistSetDescription", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id, description: description))), log: log)
	}

	public func playlistSetImageId(id: UInt32, imageId: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
				case imageId = "ImageId"
			}

			@Attribute var urn: String
			public var id: UInt32
			public var imageId: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistSetImageId"
			}

			var action: SoapAction
		}
		try await post(action: "PlaylistSetImageId", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id, imageId: imageId))), log: log)
	}

	public struct PlaylistInsertResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case newId = "NewId"
		}

		public var newId: UInt32

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))PlaylistInsertResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))newId: \(newId)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func playlistInsert(afterId: UInt32, name: String, description: String, imageId: UInt32, log: UPnPService.MessageLog = .none) async throws -> PlaylistInsertResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case afterId = "AfterId"
				case name = "Name"
				case description = "Description"
				case imageId = "ImageId"
			}

			@Attribute var urn: String
			public var afterId: UInt32
			public var name: String
			public var description: String
			public var imageId: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistInsert"
				case response = "u:PlaylistInsertResponse"
			}

			var action: SoapAction?
			var response: PlaylistInsertResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "PlaylistInsert", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), afterId: afterId, name: name, description: description, imageId: imageId))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public func playlistDeleteId(value: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case value = "Value"
			}

			@Attribute var urn: String
			public var value: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistDeleteId"
			}

			var action: SoapAction
		}
		try await post(action: "PlaylistDeleteId", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), value: value))), log: log)
	}

	public func playlistMove(id: UInt32, afterId: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
				case afterId = "AfterId"
			}

			@Attribute var urn: String
			public var id: UInt32
			public var afterId: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistMove"
			}

			var action: SoapAction
		}
		try await post(action: "PlaylistMove", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id, afterId: afterId))), log: log)
	}

	public struct PlaylistsMaxResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case value = "Value"
		}

		public var value: UInt32

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))PlaylistsMaxResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))value: \(value)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func playlistsMax(log: UPnPService.MessageLog = .none) async throws -> PlaylistsMaxResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistsMax"
				case response = "u:PlaylistsMaxResponse"
			}

			var action: SoapAction?
			var response: PlaylistsMaxResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "PlaylistsMax", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct TracksMaxResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case value = "Value"
		}

		public var value: UInt32

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))TracksMaxResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))value: \(value)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func tracksMax(log: UPnPService.MessageLog = .none) async throws -> TracksMaxResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:TracksMax"
				case response = "u:TracksMaxResponse"
			}

			var action: SoapAction?
			var response: TracksMaxResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "TracksMax", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct PlaylistArraysResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case token = "Token"
			case idArrayData = "IdArray"
			case tokenArrayData = "TokenArray"
		}

		public var token: UInt32
		public var idArrayData: Data?
		public var idArray: [UInt32]? {
			idArrayData?.toArray(type: UInt32.self).map { $0.bigEndian }
		}
		public var tokenArrayData: Data?
		public var tokenArray: [UInt32]? {
			tokenArrayData?.toArray(type: UInt32.self).map { $0.bigEndian }
		}

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))PlaylistArraysResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))token: \(token)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func playlistArrays(log: UPnPService.MessageLog = .none) async throws -> PlaylistArraysResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
			}

			@Attribute var urn: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistArrays"
				case response = "u:PlaylistArraysResponse"
			}

			var action: SoapAction?
			var response: PlaylistArraysResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "PlaylistArrays", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType)))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct PlaylistArraysChangedResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case value = "Value"
		}

		public var value: Bool

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))PlaylistArraysChangedResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))value: \(value == true ? "true" : "false")")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func playlistArraysChanged(token: UInt32, log: UPnPService.MessageLog = .none) async throws -> PlaylistArraysChangedResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case token = "Token"
			}

			@Attribute var urn: String
			public var token: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:PlaylistArraysChanged"
				case response = "u:PlaylistArraysChangedResponse"
			}

			var action: SoapAction?
			var response: PlaylistArraysChangedResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "PlaylistArraysChanged", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), token: token))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct ReadResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case metadata = "Metadata"
		}

		public var metadata: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))ReadResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))metadata: '\(metadata)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func read(id: UInt32, trackId: UInt32, log: UPnPService.MessageLog = .none) async throws -> ReadResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
				case trackId = "TrackId"
			}

			@Attribute var urn: String
			public var id: UInt32
			public var trackId: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:Read"
				case response = "u:ReadResponse"
			}

			var action: SoapAction?
			var response: ReadResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "Read", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id, trackId: trackId))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct ReadListResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case trackList = "TrackList"
		}

		public var trackList: String

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))ReadListResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))trackList: '\(trackList)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func readList(id: UInt32, trackIdList: String, log: UPnPService.MessageLog = .none) async throws -> ReadListResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
				case trackIdList = "TrackIdList"
			}

			@Attribute var urn: String
			public var id: UInt32
			public var trackIdList: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:ReadList"
				case response = "u:ReadListResponse"
			}

			var action: SoapAction?
			var response: ReadListResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "ReadList", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id, trackIdList: trackIdList))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public struct InsertResponse: Codable {
		enum CodingKeys: String, CodingKey {
			case newTrackId = "NewTrackId"
		}

		public var newTrackId: UInt32

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))InsertResponse {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))newTrackId: \(newTrackId)")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}
	public func insert(id: UInt32, afterTrackId: UInt32, udn: String, metadataId: String, log: UPnPService.MessageLog = .none) async throws -> InsertResponse {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case id = "Id"
				case afterTrackId = "AfterTrackId"
				case udn = "Udn"
				case metadataId = "MetadataId"
			}

			@Attribute var urn: String
			public var id: UInt32
			public var afterTrackId: UInt32
			public var udn: String
			public var metadataId: String
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:Insert"
				case response = "u:InsertResponse"
			}

			var action: SoapAction?
			var response: InsertResponse?
		}
		let result: Envelope<Body> = try await postWithResult(action: "Insert", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), id: id, afterTrackId: afterTrackId, udn: udn, metadataId: metadataId))), log: log)

		guard let response = result.body.response else { throw ServiceParseError.noValidResponse }
		return response
	}

	public func deleteId(trackId: UInt32, value: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case trackId = "TrackId"
				case value = "Value"
			}

			@Attribute var urn: String
			public var trackId: UInt32
			public var value: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:DeleteId"
			}

			var action: SoapAction
		}
		try await post(action: "DeleteId", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), trackId: trackId, value: value))), log: log)
	}

	public func deleteAll(trackId: UInt32, log: UPnPService.MessageLog = .none) async throws {
		struct SoapAction: Codable {
			enum CodingKeys: String, CodingKey {
				case urn = "xmlns:u"
				case trackId = "TrackId"
			}

			@Attribute var urn: String
			public var trackId: UInt32
		}
		struct Body: Codable {
			enum CodingKeys: String, CodingKey {
				case action = "u:DeleteAll"
			}

			var action: SoapAction
		}
		try await post(action: "DeleteAll", envelope: Envelope(body: Body(action: SoapAction(urn: Attribute(serviceType), trackId: trackId))), log: log)
	}

}

// Event parser
extension OpenHomePlaylistManager1Service {
	public struct State: Codable {
		enum CodingKeys: String, CodingKey {
			case metadata = "Metadata"
			case imagesXml = "ImagesXml"
			case idArrayData = "IdArray"
			case tokenArrayData = "TokenArray"
			case playlistsMax = "PlaylistsMax"
			case tracksMax = "TracksMax"
		}

		public var metadata: String?
		public var imagesXml: String?
		public var idArrayData: Data?
		public var idArray: [UInt32]? {
			idArrayData?.toArray(type: UInt32.self).map { $0.bigEndian }
		}
		public var tokenArrayData: Data?
		public var tokenArray: [UInt32]? {
			tokenArrayData?.toArray(type: UInt32.self).map { $0.bigEndian }
		}
		public var playlistsMax: UInt32?
		public var tracksMax: UInt32?

		public func log(deep: Bool = false, indent: Int = 0) {
			Logger.swiftUPnP.debug("\(Logger.indent(indent))OpenHomePlaylistManager1ServiceState {")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))metadata: '\(metadata ?? "nil")'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))imagesXml: '\(imagesXml ?? "nil")'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))playlistsMax: \(playlistsMax ?? 0)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent+1))tracksMax: \(tracksMax ?? 0)'")
			Logger.swiftUPnP.debug("\(Logger.indent(indent))}")
		}
	}

	public func state(xml: Data) throws -> State {
		struct PropertySet: Codable {
			var property: [State]
		}

		let decoder = XMLDecoder()
		decoder.shouldProcessNamespaces = true
		let propertySet = try decoder.decode(PropertySet.self, from: xml)

		return propertySet.property.reduce(State()) { partialResult, property in
			var result = partialResult
			if let metadata = property.metadata {
				result.metadata = metadata
			}
			if let imagesXml = property.imagesXml {
				result.imagesXml = imagesXml
			}
			if let idArrayData = property.idArrayData {
				result.idArrayData = idArrayData
			}
			if let tokenArrayData = property.tokenArrayData {
				result.tokenArrayData = tokenArrayData
			}
			if let playlistsMax = property.playlistsMax {
				result.playlistsMax = playlistsMax
			}
			if let tracksMax = property.tracksMax {
				result.tracksMax = tracksMax
			}
			return result
		}
	}

	public var stateSubject: AnyPublisher<State, Never> {
		subscribedEventPublisher
			.compactMap { [weak self] in
				guard let self else { return nil }

				return try? self.state(xml: $0)
			}
			.eraseToAnyPublisher()
	}
}
